// Generated by `wit-bindgen` 0.11.0. DO NOT EDIT!
#ifndef __BINDINGS_HELLO_COSMO_H
#define __BINDINGS_HELLO_COSMO_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>

typedef struct {
  char*ptr;
  size_t len;
} hello_cosmo_string_t;

// A "pollable" handle.
// 
// This is conceptually represents a `stream<_, _>`, or in other words,
// a stream that one can wait on, repeatedly, but which does not itself
// produce any data. It's temporary scaffolding until component-model's
// async features are ready.
// 
// And at present, it is a `u32` instead of being an actual handle, until
// the wit-bindgen implementation of handles and resources is ready.
// 
// `pollable` lifetimes are not automatically managed. Users must ensure
// that they do not outlive the resource they reference.
// 
// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
typedef uint32_t wasi_poll_poll_pollable_t;

typedef struct {
  wasi_poll_poll_pollable_t *ptr;
  size_t len;
} hello_cosmo_list_wasi_poll_poll_pollable_t;

typedef struct {
  bool *ptr;
  size_t len;
} hello_cosmo_list_bool_t;

typedef wasi_poll_poll_pollable_t wasi_io_streams_pollable_t;

// An error type returned from a stream operation.
// 
// TODO: need to figure out the actual contents of this error. Used to be
// an empty record but that's no longer allowed. The `dummy` field is
// only here to have this be a valid in the component model by being
// non-empty.
typedef struct {
  uint32_t dummy;
} wasi_io_streams_stream_error_t;

// Streams provide a sequence of data and then end; once they end, they
// no longer provide any further data.
// 
// For example, a stream reading from a file ends when the stream reaches
// the end of the file. For another example, a stream reading from a
// socket ends when the socket is closed.
typedef uint8_t wasi_io_streams_stream_status_t;

// The stream is open and may produce further data.
#define WASI_IO_STREAMS_STREAM_STATUS_OPEN 0
// When reading, this indicates that the stream will not produce
// further data.
// When writing, this indicates that the stream will no longer be read.
// Further writes are still permitted.
#define WASI_IO_STREAMS_STREAM_STATUS_ENDED 1

// An input bytestream. In the future, this will be replaced by handle
// types.
// 
// This conceptually represents a `stream<u8, _>`. It's temporary
// scaffolding until component-model's async features are ready.
// 
// `input-stream`s are *non-blocking* to the extent practical on underlying
// platforms. I/O operations always return promptly; if fewer bytes are
// promptly available than requested, they return the number of bytes promptly
// available, which could even be zero. To wait for data to be available,
// use the `subscribe-to-input-stream` function to obtain a `pollable` which
// can be polled for using `wasi_poll`.
// 
// And at present, it is a `u32` instead of being an actual handle, until
// the wit-bindgen implementation of handles and resources is ready.
// 
// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
typedef uint32_t wasi_io_streams_input_stream_t;

// An output bytestream. In the future, this will be replaced by handle
// types.
// 
// This conceptually represents a `stream<u8, _>`. It's temporary
// scaffolding until component-model's async features are ready.
// 
// `output-stream`s are *non-blocking* to the extent practical on
// underlying platforms. Except where specified otherwise, I/O operations also
// always return promptly, after the number of bytes that can be written
// promptly, which could even be zero. To wait for the stream to be ready to
// accept data, the `subscribe-to-output-stream` function to obtain a
// `pollable` which can be polled for using `wasi:poll`.
// 
// And at present, it is a `u32` instead of being an actual handle, until
// the wit-bindgen implementation of handles and resources is ready.
// 
// This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).
typedef uint32_t wasi_io_streams_output_stream_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} hello_cosmo_list_u8_t;

typedef struct {
  hello_cosmo_list_u8_t f0;
  wasi_io_streams_stream_status_t f1;
} hello_cosmo_tuple2_list_u8_wasi_io_streams_stream_status_t;

typedef struct {
  bool is_err;
  union {
    hello_cosmo_tuple2_list_u8_wasi_io_streams_stream_status_t ok;
    wasi_io_streams_stream_error_t err;
  } val;
} hello_cosmo_result_tuple2_list_u8_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t;

typedef struct {
  uint64_t f0;
  wasi_io_streams_stream_status_t f1;
} hello_cosmo_tuple2_u64_wasi_io_streams_stream_status_t;

typedef struct {
  bool is_err;
  union {
    hello_cosmo_tuple2_u64_wasi_io_streams_stream_status_t ok;
    wasi_io_streams_stream_error_t err;
  } val;
} hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t;

typedef wasi_io_streams_input_stream_t wasi_http_http_types_input_stream_t;

typedef wasi_io_streams_output_stream_t wasi_http_http_types_output_stream_t;

typedef wasi_poll_poll_pollable_t wasi_http_http_types_pollable_t;

typedef struct {
  uint8_t tag;
  union {
    hello_cosmo_string_t other;
  } val;
} wasi_http_http_types_method_t;

#define WASI_HTTP_HTTP_TYPES_METHOD_GET 0
#define WASI_HTTP_HTTP_TYPES_METHOD_HEAD 1
#define WASI_HTTP_HTTP_TYPES_METHOD_POST 2
#define WASI_HTTP_HTTP_TYPES_METHOD_PUT 3
#define WASI_HTTP_HTTP_TYPES_METHOD_DELETE 4
#define WASI_HTTP_HTTP_TYPES_METHOD_CONNECT 5
#define WASI_HTTP_HTTP_TYPES_METHOD_OPTIONS 6
#define WASI_HTTP_HTTP_TYPES_METHOD_TRACE 7
#define WASI_HTTP_HTTP_TYPES_METHOD_PATCH 8
#define WASI_HTTP_HTTP_TYPES_METHOD_OTHER 9

typedef struct {
  uint8_t tag;
  union {
    hello_cosmo_string_t other;
  } val;
} wasi_http_http_types_scheme_t;

#define WASI_HTTP_HTTP_TYPES_SCHEME_HTTP 0
#define WASI_HTTP_HTTP_TYPES_SCHEME_HTTPS 1
#define WASI_HTTP_HTTP_TYPES_SCHEME_OTHER 2

typedef struct {
  uint8_t tag;
  union {
    hello_cosmo_string_t invalid_url;
    hello_cosmo_string_t timeout_error;
    hello_cosmo_string_t protocol_error;
    hello_cosmo_string_t unexpected_error;
  } val;
} wasi_http_http_types_error_t;

#define WASI_HTTP_HTTP_TYPES_ERROR_INVALID_URL 0
#define WASI_HTTP_HTTP_TYPES_ERROR_TIMEOUT_ERROR 1
#define WASI_HTTP_HTTP_TYPES_ERROR_PROTOCOL_ERROR 2
#define WASI_HTTP_HTTP_TYPES_ERROR_UNEXPECTED_ERROR 3

typedef uint32_t wasi_http_http_types_fields_t;

typedef wasi_http_http_types_fields_t wasi_http_http_types_headers_t;

typedef wasi_http_http_types_fields_t wasi_http_http_types_trailers_t;

typedef wasi_http_http_types_input_stream_t wasi_http_http_types_incoming_stream_t;

typedef wasi_http_http_types_output_stream_t wasi_http_http_types_outgoing_stream_t;

typedef uint32_t wasi_http_http_types_future_trailers_t;

typedef uint32_t wasi_http_http_types_future_write_trailers_result_t;

typedef uint32_t wasi_http_http_types_incoming_request_t;

typedef uint32_t wasi_http_http_types_outgoing_request_t;

typedef struct {
  bool is_some;
  uint32_t val;
} hello_cosmo_option_u32_t;

typedef struct {
  hello_cosmo_option_u32_t connect_timeout_ms;
  hello_cosmo_option_u32_t first_byte_timeout_ms;
  hello_cosmo_option_u32_t between_bytes_timeout_ms;
} wasi_http_http_types_request_options_t;

typedef uint32_t wasi_http_http_types_response_outparam_t;

typedef uint16_t wasi_http_http_types_status_code_t;

typedef uint32_t wasi_http_http_types_incoming_response_t;

typedef uint32_t wasi_http_http_types_outgoing_response_t;

typedef uint32_t wasi_http_http_types_future_incoming_response_t;

typedef struct {
  hello_cosmo_string_t f0;
  hello_cosmo_list_u8_t f1;
} hello_cosmo_tuple2_string_list_u8_t;

typedef struct {
  hello_cosmo_tuple2_string_list_u8_t *ptr;
  size_t len;
} hello_cosmo_list_tuple2_string_list_u8_t;

typedef struct {
  hello_cosmo_list_u8_t *ptr;
  size_t len;
} hello_cosmo_list_list_u8_t;

typedef struct {
  bool is_some;
  wasi_http_http_types_future_trailers_t val;
} hello_cosmo_option_wasi_http_http_types_future_trailers_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_http_types_trailers_t ok;
    wasi_http_http_types_error_t err;
  } val;
} hello_cosmo_result_wasi_http_http_types_trailers_wasi_http_http_types_error_t;

typedef struct {
  bool is_some;
  hello_cosmo_result_wasi_http_http_types_trailers_wasi_http_http_types_error_t val;
} hello_cosmo_option_result_wasi_http_http_types_trailers_wasi_http_http_types_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_http_types_error_t err;
  } val;
} hello_cosmo_result_void_wasi_http_http_types_error_t;

typedef struct {
  bool is_some;
  hello_cosmo_result_void_wasi_http_http_types_error_t val;
} hello_cosmo_option_result_void_wasi_http_http_types_error_t;

typedef struct {
  bool is_some;
  hello_cosmo_string_t val;
} hello_cosmo_option_string_t;

typedef struct {
  bool is_some;
  wasi_http_http_types_scheme_t val;
} hello_cosmo_option_wasi_http_http_types_scheme_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_http_types_incoming_stream_t ok;
  } val;
} hello_cosmo_result_wasi_http_http_types_incoming_stream_void_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_http_types_outgoing_request_t ok;
    wasi_http_http_types_error_t err;
  } val;
} hello_cosmo_result_wasi_http_http_types_outgoing_request_wasi_http_http_types_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_http_types_outgoing_stream_t ok;
  } val;
} hello_cosmo_result_wasi_http_http_types_outgoing_stream_void_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_http_types_outgoing_response_t ok;
    wasi_http_http_types_error_t err;
  } val;
} hello_cosmo_result_wasi_http_http_types_outgoing_response_wasi_http_http_types_error_t;

typedef struct {
  bool is_err;
  union {
  } val;
} hello_cosmo_result_void_void_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_http_types_incoming_response_t ok;
    wasi_http_http_types_error_t err;
  } val;
} hello_cosmo_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_t;

typedef struct {
  bool is_some;
  hello_cosmo_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_t val;
} hello_cosmo_option_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_t;

typedef wasi_http_http_types_incoming_request_t wasi_http_incoming_handler_incoming_request_t;

typedef wasi_http_http_types_response_outparam_t wasi_http_incoming_handler_response_outparam_t;

// An error resource type for keyvalue operations.
// Currently, this provides only one function to return a string representation
// of the error. In the future, this will be extended to provide more information
// about the error.
typedef uint32_t wasi_keyvalue_wasi_cloud_error_error_t;

typedef wasi_io_streams_input_stream_t wasi_keyvalue_types_input_stream_t;

typedef wasi_io_streams_output_stream_t wasi_keyvalue_types_output_stream_t;

typedef wasi_keyvalue_wasi_cloud_error_error_t wasi_keyvalue_types_error_t;

// A bucket is a collection of key-value pairs. Each key-value pair is stored
// as a entry in the bucket, and the bucket itself acts as a collection of all
// these entries.
// 
// It is worth noting that the exact terminology for bucket in key-value stores
// can very depending on the specific implementation. For example,
// 1. Amazon DynamoDB calls a collection of key-value pairs a table
// 2. Redis has hashes, sets, and sorted sets as different types of collections
// 3. Cassandra calls a collection of key-value pairs a column family
// 4. MongoDB calls a collection of key-value pairs a collection
// 5. Riak calls a collection of key-value pairs a bucket
// 6. Memcached calls a collection of key-value pairs a slab
// 7. Azure Cosmos DB calls a collection of key-value pairs a container
// 
// In this interface, we use the term `bucket` to refer to a collection of key-value
typedef uint32_t wasi_keyvalue_types_bucket_t;

// A key is a unique identifier for a value in a bucket. The key is used to
// retrieve the value from the bucket.
typedef hello_cosmo_string_t wasi_keyvalue_types_key_t;

// A list of keys
typedef struct {
  wasi_keyvalue_types_key_t *ptr;
  size_t len;
} wasi_keyvalue_types_keys_t;

// A value is the data stored in a key-value pair. The value can be of any type
// that can be represented in a byte array. It provides a way to write the value
// to the output-stream defined in the `wasi-io` interface.
typedef uint32_t wasi_keyvalue_types_outgoing_value_t;

// A incoming-value is a wrapper around a value. It provides a way to read the value
// from the input-stream defined in the `wasi-io` interface.
// 
// The incoming-value provides two ways to consume the value:
// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the
// value as a list of bytes.
// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the
// value as an input-stream.
typedef uint32_t wasi_keyvalue_types_incoming_value_t;

typedef wasi_keyvalue_types_input_stream_t wasi_keyvalue_types_incoming_value_async_body_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_keyvalue_types_incoming_value_sync_body_t;

typedef struct {
  bool is_err;
  union {
    wasi_keyvalue_types_bucket_t ok;
    wasi_keyvalue_types_error_t err;
  } val;
} hello_cosmo_result_wasi_keyvalue_types_bucket_wasi_keyvalue_types_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_keyvalue_types_output_stream_t ok;
  } val;
} hello_cosmo_result_wasi_keyvalue_types_output_stream_void_t;

typedef struct {
  bool is_err;
  union {
    wasi_keyvalue_types_incoming_value_sync_body_t ok;
    wasi_keyvalue_types_error_t err;
  } val;
} hello_cosmo_result_wasi_keyvalue_types_incoming_value_sync_body_wasi_keyvalue_types_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_keyvalue_types_incoming_value_async_body_t ok;
    wasi_keyvalue_types_error_t err;
  } val;
} hello_cosmo_result_wasi_keyvalue_types_incoming_value_async_body_wasi_keyvalue_types_error_t;

typedef wasi_keyvalue_types_bucket_t wasi_keyvalue_atomic_bucket_t;

typedef wasi_keyvalue_types_error_t wasi_keyvalue_atomic_error_t;

typedef wasi_keyvalue_types_key_t wasi_keyvalue_atomic_key_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_keyvalue_atomic_error_t err;
  } val;
} hello_cosmo_result_u64_wasi_keyvalue_atomic_error_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    wasi_keyvalue_atomic_error_t err;
  } val;
} hello_cosmo_result_bool_wasi_keyvalue_atomic_error_t;

typedef wasi_keyvalue_types_bucket_t wasi_keyvalue_batch_bucket_t;

typedef wasi_keyvalue_types_error_t wasi_keyvalue_batch_error_t;

typedef wasi_keyvalue_types_key_t wasi_keyvalue_batch_key_t;

typedef wasi_keyvalue_types_keys_t wasi_keyvalue_batch_keys_t;

typedef wasi_keyvalue_types_incoming_value_t wasi_keyvalue_batch_incoming_value_t;

typedef wasi_keyvalue_types_outgoing_value_t wasi_keyvalue_batch_outgoing_value_t;

typedef struct {
  wasi_keyvalue_batch_incoming_value_t *ptr;
  size_t len;
} hello_cosmo_list_wasi_keyvalue_batch_incoming_value_t;

typedef struct {
  bool is_err;
  union {
    hello_cosmo_list_wasi_keyvalue_batch_incoming_value_t ok;
    wasi_keyvalue_batch_error_t err;
  } val;
} hello_cosmo_result_list_wasi_keyvalue_batch_incoming_value_wasi_keyvalue_batch_error_t;

typedef struct {
  wasi_keyvalue_batch_key_t f0;
  wasi_keyvalue_batch_outgoing_value_t f1;
} hello_cosmo_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_t;

typedef struct {
  hello_cosmo_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_t *ptr;
  size_t len;
} hello_cosmo_list_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_t;

typedef struct {
  bool is_err;
  union {
    wasi_keyvalue_batch_error_t err;
  } val;
} hello_cosmo_result_void_wasi_keyvalue_batch_error_t;

typedef wasi_keyvalue_types_bucket_t wasi_keyvalue_readwrite_bucket_t;

typedef wasi_keyvalue_types_error_t wasi_keyvalue_readwrite_error_t;

typedef wasi_keyvalue_types_incoming_value_t wasi_keyvalue_readwrite_incoming_value_t;

typedef wasi_keyvalue_types_key_t wasi_keyvalue_readwrite_key_t;

typedef wasi_keyvalue_types_outgoing_value_t wasi_keyvalue_readwrite_outgoing_value_t;

typedef struct {
  bool is_err;
  union {
    wasi_keyvalue_readwrite_incoming_value_t ok;
    wasi_keyvalue_readwrite_error_t err;
  } val;
} hello_cosmo_result_wasi_keyvalue_readwrite_incoming_value_wasi_keyvalue_readwrite_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_keyvalue_readwrite_error_t err;
  } val;
} hello_cosmo_result_void_wasi_keyvalue_readwrite_error_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    wasi_keyvalue_readwrite_error_t err;
  } val;
} hello_cosmo_result_bool_wasi_keyvalue_readwrite_error_t;

// Imported Functions from `wasi:poll/poll`
// Dispose of the specified `pollable`, after which it may no longer
// be used.
void wasi_poll_poll_drop_pollable(wasi_poll_poll_pollable_t this);
// Poll for completion on a set of pollables.
// 
// This function takes a list of pollables, which identify I/O sources of
// interest, and waits until one or more of the events is ready for I/O.
// 
// The result `list<bool>` is the same length as the argument
// `list<pollable>`, and indicates the readiness of each corresponding
// element in that list, with true indicating ready. A single call can
// return multiple true elements.
// 
// A timeout can be implemented by adding a pollable from the
// wasi-clocks API to the list.
// 
// This function does not return a `result`; polling in itself does not
// do any I/O so it doesn't fail. If any of the I/O sources identified by
// the pollables has an error, it is indicated by marking the source as
// ready in the `list<bool>`.
// 
// The "oneoff" in the name refers to the fact that this function must do a
// linear scan through the entire list of subscriptions, which may be
// inefficient if the number is large and the same subscriptions are used
// many times. In the future, this is expected to be obsoleted by the
// component model async proposal, which will include a scalable waiting
// facility.
void wasi_poll_poll_poll_oneoff(hello_cosmo_list_wasi_poll_poll_pollable_t *in, hello_cosmo_list_bool_t *ret);

// Imported Functions from `wasi:io/streams`
// Perform a non-blocking read from the stream.
// 
// This function returns a list of bytes containing the data that was
// read, along with a `stream-status` which, indicates whether further
// reads are expected to produce data. The returned list will contain up to
// `len` bytes; it may return fewer than requested, but not more.
// 
// Once a stream has reached the end, subsequent calls to read or
// `skip` will always report end-of-stream rather than producing more
// data.
// 
// If `len` is 0, it represents a request to read 0 bytes, which should
// always succeed, assuming the stream hasn't reached its end yet, and
// return an empty list.
// 
// The len here is a `u64`, but some callees may not be able to allocate
// a buffer as large as that would imply.
// FIXME: describe what happens if allocation fails.
// 
// When the returned `stream-status` is `open`, the length of the returned
// value may be less than `len`. When an empty list is returned, this
// indicates that no more bytes were available from the stream at that
// time. In that case the subscribe-to-input-stream pollable will indicate
// when additional bytes are available for reading.
void wasi_io_streams_read(wasi_io_streams_input_stream_t this, uint64_t len, hello_cosmo_result_tuple2_list_u8_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Read bytes from a stream, with blocking.
// 
// This is similar to `read`, except that it blocks until at least one
// byte can be read.
void wasi_io_streams_blocking_read(wasi_io_streams_input_stream_t this, uint64_t len, hello_cosmo_result_tuple2_list_u8_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Skip bytes from a stream.
// 
// This is similar to the `read` function, but avoids copying the
// bytes into the instance.
// 
// Once a stream has reached the end, subsequent calls to read or
// `skip` will always report end-of-stream rather than producing more
// data.
// 
// This function returns the number of bytes skipped, along with a bool
// indicating whether the end of the stream was reached. The returned
// value will be at most `len`; it may be less.
void wasi_io_streams_skip(wasi_io_streams_input_stream_t this, uint64_t len, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Skip bytes from a stream, with blocking.
// 
// This is similar to `skip`, except that it blocks until at least one
// byte can be consumed.
void wasi_io_streams_blocking_skip(wasi_io_streams_input_stream_t this, uint64_t len, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Create a `pollable` which will resolve once either the specified stream
// has bytes available to read or the other end of the stream has been
// closed.
wasi_io_streams_pollable_t wasi_io_streams_subscribe_to_input_stream(wasi_io_streams_input_stream_t this);
// Dispose of the specified `input-stream`, after which it may no longer
// be used.
void wasi_io_streams_drop_input_stream(wasi_io_streams_input_stream_t this);
// Perform a non-blocking write of bytes to a stream.
// 
// This function returns a `u64` and a `stream-status`. The `u64` indicates
// the number of bytes from `buf` that were written, which may be less than
// the length of `buf`. The `stream-status` indicates if further writes to
// the stream are expected to be read.
// 
// When the returned `stream-status` is `open`, the `u64` return value may
// be less than the length of `buf`. This indicates that no more bytes may
// be written to the stream promptly. In that case the
// subscribe-to-output-stream pollable will indicate when additional bytes
// may be promptly written.
// 
// TODO: document what happens when an empty list is written
void wasi_io_streams_write(wasi_io_streams_output_stream_t this, hello_cosmo_list_u8_t *buf, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Write bytes to a stream, with blocking.
// 
// This is similar to `write`, except that it blocks until at least one
// byte can be written.
void wasi_io_streams_blocking_write(wasi_io_streams_output_stream_t this, hello_cosmo_list_u8_t *buf, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Write multiple zero bytes to a stream.
// 
// This function returns a `u64` indicating the number of zero bytes
// that were written; it may be less than `len`.
void wasi_io_streams_write_zeroes(wasi_io_streams_output_stream_t this, uint64_t len, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Write multiple zero bytes to a stream, with blocking.
// 
// This is similar to `write-zeroes`, except that it blocks until at least
// one byte can be written.
void wasi_io_streams_blocking_write_zeroes(wasi_io_streams_output_stream_t this, uint64_t len, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Read from one stream and write to another.
// 
// This function returns the number of bytes transferred; it may be less
// than `len`.
// 
// Unlike other I/O functions, this function blocks until all the data
// read from the input stream has been written to the output stream.
void wasi_io_streams_splice(wasi_io_streams_output_stream_t this, wasi_io_streams_input_stream_t src, uint64_t len, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Read from one stream and write to another, with blocking.
// 
// This is similar to `splice`, except that it blocks until at least
// one byte can be read.
void wasi_io_streams_blocking_splice(wasi_io_streams_output_stream_t this, wasi_io_streams_input_stream_t src, uint64_t len, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Forward the entire contents of an input stream to an output stream.
// 
// This function repeatedly reads from the input stream and writes
// the data to the output stream, until the end of the input stream
// is reached, or an error is encountered.
// 
// Unlike other I/O functions, this function blocks until the end
// of the input stream is seen and all the data has been written to
// the output stream.
// 
// This function returns the number of bytes transferred, and the status of
// the output stream.
void wasi_io_streams_forward(wasi_io_streams_output_stream_t this, wasi_io_streams_input_stream_t src, hello_cosmo_result_tuple2_u64_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ret);
// Create a `pollable` which will resolve once either the specified stream
// is ready to accept bytes or the other end of the stream has been closed.
wasi_io_streams_pollable_t wasi_io_streams_subscribe_to_output_stream(wasi_io_streams_output_stream_t this);
// Dispose of the specified `output-stream`, after which it may no longer
// be used.
void wasi_io_streams_drop_output_stream(wasi_io_streams_output_stream_t this);

// Imported Functions from `wasi:keyvalue/wasi-cloud-error`
void wasi_keyvalue_wasi_cloud_error_drop_error(wasi_keyvalue_wasi_cloud_error_error_t error);
void wasi_keyvalue_wasi_cloud_error_trace(wasi_keyvalue_wasi_cloud_error_error_t error, hello_cosmo_string_t *ret);

// Imported Functions from `wasi:keyvalue/types`
void wasi_keyvalue_types_drop_bucket(wasi_keyvalue_types_bucket_t bucket);
void wasi_keyvalue_types_open_bucket(hello_cosmo_string_t *name, hello_cosmo_result_wasi_keyvalue_types_bucket_wasi_keyvalue_types_error_t *ret);
void wasi_keyvalue_types_drop_outgoing_value(wasi_keyvalue_types_outgoing_value_t outgoing_value);
wasi_keyvalue_types_outgoing_value_t wasi_keyvalue_types_new_outgoing_value(void);
void wasi_keyvalue_types_outgoing_value_write_body(wasi_keyvalue_types_outgoing_value_t outgoing_value, hello_cosmo_result_wasi_keyvalue_types_output_stream_void_t *ret);
void wasi_keyvalue_types_drop_incoming_value(wasi_keyvalue_types_incoming_value_t incoming_value);
void wasi_keyvalue_types_incoming_value_consume_sync(wasi_keyvalue_types_incoming_value_t incoming_value, hello_cosmo_result_wasi_keyvalue_types_incoming_value_sync_body_wasi_keyvalue_types_error_t *ret);
void wasi_keyvalue_types_incoming_value_consume_async(wasi_keyvalue_types_incoming_value_t incoming_value, hello_cosmo_result_wasi_keyvalue_types_incoming_value_async_body_wasi_keyvalue_types_error_t *ret);
uint64_t wasi_keyvalue_types_size(wasi_keyvalue_types_incoming_value_t incoming_value);

// Imported Functions from `wasi:keyvalue/readwrite`
// Get the value associated with the key in the bucket. It returns a incoming-value
// that can be consumed to get the value.
// 
// If the key does not exist in the bucket, it returns an error.
void wasi_keyvalue_readwrite_get(wasi_keyvalue_readwrite_bucket_t bucket, wasi_keyvalue_readwrite_key_t *key, hello_cosmo_result_wasi_keyvalue_readwrite_incoming_value_wasi_keyvalue_readwrite_error_t *ret);
// Set the value associated with the key in the bucket. If the key already
// exists in the bucket, it overwrites the value.
// 
// If the key does not exist in the bucket, it creates a new key-value pair.
// If any other error occurs, it returns an error.
void wasi_keyvalue_readwrite_set(wasi_keyvalue_readwrite_bucket_t bucket, wasi_keyvalue_readwrite_key_t *key, wasi_keyvalue_readwrite_outgoing_value_t outgoing_value, hello_cosmo_result_void_wasi_keyvalue_readwrite_error_t *ret);
// Delete the key-value pair associated with the key in the bucket.
// 
// If the key does not exist in the bucket, it returns an error.
void wasi_keyvalue_readwrite_delete(wasi_keyvalue_readwrite_bucket_t bucket, wasi_keyvalue_readwrite_key_t *key, hello_cosmo_result_void_wasi_keyvalue_readwrite_error_t *ret);
// Check if the key exists in the bucket.
void wasi_keyvalue_readwrite_exists(wasi_keyvalue_readwrite_bucket_t bucket, wasi_keyvalue_readwrite_key_t *key, hello_cosmo_result_bool_wasi_keyvalue_readwrite_error_t *ret);

// Imported Functions from `wasi:keyvalue/atomic`
// Atomically increment the value associated with the key in the bucket by the
// given delta. It returns the new value.
// 
// If the key does not exist in the bucket, it creates a new key-value pair
// with the value set to the given delta.
// 
// If any other error occurs, it returns an error.
void wasi_keyvalue_atomic_increment(wasi_keyvalue_atomic_bucket_t bucket, wasi_keyvalue_atomic_key_t *key, uint64_t delta, hello_cosmo_result_u64_wasi_keyvalue_atomic_error_t *ret);
// Atomically compare and swap the value associated with the key in the bucket.
// It returns a boolean indicating if the swap was successful.
// 
// If the key does not exist in the bucket, it returns an error.
void wasi_keyvalue_atomic_compare_and_swap(wasi_keyvalue_atomic_bucket_t bucket, wasi_keyvalue_atomic_key_t *key, uint64_t old, uint64_t new, hello_cosmo_result_bool_wasi_keyvalue_atomic_error_t *ret);

// Imported Functions from `wasi:keyvalue/batch`
// Get the values associated with the keys in the bucket. It returns a list of
// incoming-values that can be consumed to get the values.
// 
// If any of the keys do not exist in the bucket, it returns an error.
void wasi_keyvalue_batch_get_many(wasi_keyvalue_batch_bucket_t bucket, wasi_keyvalue_batch_keys_t *keys, hello_cosmo_result_list_wasi_keyvalue_batch_incoming_value_wasi_keyvalue_batch_error_t *ret);
// Get all the keys in the bucket. It returns a list of keys.
void wasi_keyvalue_batch_get_keys(wasi_keyvalue_batch_bucket_t bucket, wasi_keyvalue_batch_keys_t *ret);
// Set the values associated with the keys in the bucket. If the key already
// exists in the bucket, it overwrites the value.
// 
// If any of the keys do not exist in the bucket, it creates a new key-value pair.
// If any other error occurs, it returns an error.
void wasi_keyvalue_batch_set_many(wasi_keyvalue_batch_bucket_t bucket, wasi_keyvalue_batch_keys_t *keys, hello_cosmo_list_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_t *values, hello_cosmo_result_void_wasi_keyvalue_batch_error_t *ret);
// Delete the key-value pairs associated with the keys in the bucket.
// 
// If any of the keys do not exist in the bucket, it skips the key.
// If any other error occurs, it returns an error.
void wasi_keyvalue_batch_delete_many(wasi_keyvalue_batch_bucket_t bucket, wasi_keyvalue_batch_keys_t *keys, hello_cosmo_result_void_wasi_keyvalue_batch_error_t *ret);

// Imported Functions from `wasi:http/http-types`
void wasi_http_http_types_drop_fields(wasi_http_http_types_fields_t fields);
wasi_http_http_types_fields_t wasi_http_http_types_new_fields(hello_cosmo_list_tuple2_string_list_u8_t *entries);
void wasi_http_http_types_fields_get(wasi_http_http_types_fields_t fields, hello_cosmo_string_t *name, hello_cosmo_list_list_u8_t *ret);
void wasi_http_http_types_fields_set(wasi_http_http_types_fields_t fields, hello_cosmo_string_t *name, hello_cosmo_list_list_u8_t *value);
void wasi_http_http_types_fields_delete(wasi_http_http_types_fields_t fields, hello_cosmo_string_t *name);
void wasi_http_http_types_fields_append(wasi_http_http_types_fields_t fields, hello_cosmo_string_t *name, hello_cosmo_list_u8_t *value);
void wasi_http_http_types_fields_entries(wasi_http_http_types_fields_t fields, hello_cosmo_list_tuple2_string_list_u8_t *ret);
wasi_http_http_types_fields_t wasi_http_http_types_fields_clone(wasi_http_http_types_fields_t fields);
void wasi_http_http_types_finish_incoming_stream(wasi_http_http_types_incoming_stream_t s, hello_cosmo_option_wasi_http_http_types_future_trailers_t *ret);
void wasi_http_http_types_finish_outgoing_stream(wasi_http_http_types_outgoing_stream_t s);
wasi_http_http_types_future_write_trailers_result_t wasi_http_http_types_finish_outgoing_stream_with_trailers(wasi_http_http_types_outgoing_stream_t s, wasi_http_http_types_trailers_t trailers);
void wasi_http_http_types_drop_future_trailers(wasi_http_http_types_future_trailers_t f);
void wasi_http_http_types_future_trailers_get(wasi_http_http_types_future_trailers_t f, hello_cosmo_option_result_wasi_http_http_types_trailers_wasi_http_http_types_error_t *ret);
wasi_http_http_types_pollable_t wasi_http_http_types_listen_to_future_trailers(wasi_http_http_types_future_trailers_t f);
void wasi_http_http_types_drop_future_write_trailers_result(wasi_http_http_types_future_write_trailers_result_t f);
void wasi_http_http_types_future_write_trailers_result_get(wasi_http_http_types_future_write_trailers_result_t f, hello_cosmo_option_result_void_wasi_http_http_types_error_t *ret);
wasi_http_http_types_pollable_t wasi_http_http_types_listen_to_future_write_trailers_result(wasi_http_http_types_future_write_trailers_result_t f);
void wasi_http_http_types_drop_incoming_request(wasi_http_http_types_incoming_request_t request);
void wasi_http_http_types_drop_outgoing_request(wasi_http_http_types_outgoing_request_t request);
void wasi_http_http_types_incoming_request_method(wasi_http_http_types_incoming_request_t request, wasi_http_http_types_method_t *ret);
void wasi_http_http_types_incoming_request_path_with_query(wasi_http_http_types_incoming_request_t request, hello_cosmo_option_string_t *ret);
void wasi_http_http_types_incoming_request_scheme(wasi_http_http_types_incoming_request_t request, hello_cosmo_option_wasi_http_http_types_scheme_t *ret);
void wasi_http_http_types_incoming_request_authority(wasi_http_http_types_incoming_request_t request, hello_cosmo_option_string_t *ret);
wasi_http_http_types_headers_t wasi_http_http_types_incoming_request_headers(wasi_http_http_types_incoming_request_t request);
void wasi_http_http_types_incoming_request_consume(wasi_http_http_types_incoming_request_t request, hello_cosmo_result_wasi_http_http_types_incoming_stream_void_t *ret);
void wasi_http_http_types_new_outgoing_request(wasi_http_http_types_method_t *method, hello_cosmo_option_string_t *path_with_query, hello_cosmo_option_wasi_http_http_types_scheme_t *scheme, hello_cosmo_option_string_t *authority, wasi_http_http_types_headers_t headers, hello_cosmo_result_wasi_http_http_types_outgoing_request_wasi_http_http_types_error_t *ret);
void wasi_http_http_types_outgoing_request_write(wasi_http_http_types_outgoing_request_t request, hello_cosmo_result_wasi_http_http_types_outgoing_stream_void_t *ret);
void wasi_http_http_types_drop_response_outparam(wasi_http_http_types_response_outparam_t response);
void wasi_http_http_types_set_response_outparam(wasi_http_http_types_response_outparam_t param, hello_cosmo_result_wasi_http_http_types_outgoing_response_wasi_http_http_types_error_t *response, hello_cosmo_result_void_void_t *ret);
void wasi_http_http_types_drop_incoming_response(wasi_http_http_types_incoming_response_t response);
void wasi_http_http_types_drop_outgoing_response(wasi_http_http_types_outgoing_response_t response);
wasi_http_http_types_status_code_t wasi_http_http_types_incoming_response_status(wasi_http_http_types_incoming_response_t response);
wasi_http_http_types_headers_t wasi_http_http_types_incoming_response_headers(wasi_http_http_types_incoming_response_t response);
void wasi_http_http_types_incoming_response_consume(wasi_http_http_types_incoming_response_t response, hello_cosmo_result_wasi_http_http_types_incoming_stream_void_t *ret);
void wasi_http_http_types_new_outgoing_response(wasi_http_http_types_status_code_t status_code, wasi_http_http_types_headers_t headers, hello_cosmo_result_wasi_http_http_types_outgoing_response_wasi_http_http_types_error_t *ret);
void wasi_http_http_types_outgoing_response_write(wasi_http_http_types_outgoing_response_t response, hello_cosmo_result_wasi_http_http_types_outgoing_stream_void_t *ret);
void wasi_http_http_types_drop_future_incoming_response(wasi_http_http_types_future_incoming_response_t f);
void wasi_http_http_types_future_incoming_response_get(wasi_http_http_types_future_incoming_response_t f, hello_cosmo_option_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_t *ret);
wasi_http_http_types_pollable_t wasi_http_http_types_listen_to_future_incoming_response(wasi_http_http_types_future_incoming_response_t f);

// Exported Functions from `wasi:http/incoming-handler`
void exports_wasi_http_incoming_handler_handle(wasi_http_incoming_handler_incoming_request_t request, wasi_http_incoming_handler_response_outparam_t response_out);

// Helper Functions

void hello_cosmo_list_wasi_poll_poll_pollable_free(hello_cosmo_list_wasi_poll_poll_pollable_t *ptr);
void hello_cosmo_list_bool_free(hello_cosmo_list_bool_t *ptr);
void hello_cosmo_list_u8_free(hello_cosmo_list_u8_t *ptr);
void hello_cosmo_tuple2_list_u8_wasi_io_streams_stream_status_free(hello_cosmo_tuple2_list_u8_wasi_io_streams_stream_status_t *ptr);
void hello_cosmo_result_tuple2_list_u8_wasi_io_streams_stream_status_wasi_io_streams_stream_error_free(hello_cosmo_result_tuple2_list_u8_wasi_io_streams_stream_status_wasi_io_streams_stream_error_t *ptr);
void wasi_http_http_types_method_free(wasi_http_http_types_method_t *ptr);
void wasi_http_http_types_scheme_free(wasi_http_http_types_scheme_t *ptr);
void wasi_http_http_types_error_free(wasi_http_http_types_error_t *ptr);
void hello_cosmo_tuple2_string_list_u8_free(hello_cosmo_tuple2_string_list_u8_t *ptr);
void hello_cosmo_list_tuple2_string_list_u8_free(hello_cosmo_list_tuple2_string_list_u8_t *ptr);
void hello_cosmo_list_list_u8_free(hello_cosmo_list_list_u8_t *ptr);
void hello_cosmo_result_wasi_http_http_types_trailers_wasi_http_http_types_error_free(hello_cosmo_result_wasi_http_http_types_trailers_wasi_http_http_types_error_t *ptr);
void hello_cosmo_option_result_wasi_http_http_types_trailers_wasi_http_http_types_error_free(hello_cosmo_option_result_wasi_http_http_types_trailers_wasi_http_http_types_error_t *ptr);
void hello_cosmo_result_void_wasi_http_http_types_error_free(hello_cosmo_result_void_wasi_http_http_types_error_t *ptr);
void hello_cosmo_option_result_void_wasi_http_http_types_error_free(hello_cosmo_option_result_void_wasi_http_http_types_error_t *ptr);
void hello_cosmo_option_string_free(hello_cosmo_option_string_t *ptr);
void hello_cosmo_option_wasi_http_http_types_scheme_free(hello_cosmo_option_wasi_http_http_types_scheme_t *ptr);
void hello_cosmo_result_wasi_http_http_types_outgoing_request_wasi_http_http_types_error_free(hello_cosmo_result_wasi_http_http_types_outgoing_request_wasi_http_http_types_error_t *ptr);
void hello_cosmo_result_wasi_http_http_types_outgoing_response_wasi_http_http_types_error_free(hello_cosmo_result_wasi_http_http_types_outgoing_response_wasi_http_http_types_error_t *ptr);
void hello_cosmo_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_free(hello_cosmo_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_t *ptr);
void hello_cosmo_option_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_free(hello_cosmo_option_result_wasi_http_http_types_incoming_response_wasi_http_http_types_error_t *ptr);
void wasi_keyvalue_types_key_free(wasi_keyvalue_types_key_t *ptr);
void wasi_keyvalue_types_keys_free(wasi_keyvalue_types_keys_t *ptr);
void wasi_keyvalue_types_incoming_value_sync_body_free(wasi_keyvalue_types_incoming_value_sync_body_t *ptr);
void hello_cosmo_result_wasi_keyvalue_types_incoming_value_sync_body_wasi_keyvalue_types_error_free(hello_cosmo_result_wasi_keyvalue_types_incoming_value_sync_body_wasi_keyvalue_types_error_t *ptr);
void wasi_keyvalue_atomic_key_free(wasi_keyvalue_atomic_key_t *ptr);
void wasi_keyvalue_batch_key_free(wasi_keyvalue_batch_key_t *ptr);
void wasi_keyvalue_batch_keys_free(wasi_keyvalue_batch_keys_t *ptr);
void hello_cosmo_list_wasi_keyvalue_batch_incoming_value_free(hello_cosmo_list_wasi_keyvalue_batch_incoming_value_t *ptr);
void hello_cosmo_result_list_wasi_keyvalue_batch_incoming_value_wasi_keyvalue_batch_error_free(hello_cosmo_result_list_wasi_keyvalue_batch_incoming_value_wasi_keyvalue_batch_error_t *ptr);
void hello_cosmo_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_free(hello_cosmo_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_t *ptr);
void hello_cosmo_list_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_free(hello_cosmo_list_tuple2_wasi_keyvalue_batch_key_wasi_keyvalue_batch_outgoing_value_t *ptr);
void wasi_keyvalue_readwrite_key_free(wasi_keyvalue_readwrite_key_t *ptr);
void hello_cosmo_string_set(hello_cosmo_string_t *ret, const char*s);
void hello_cosmo_string_dup(hello_cosmo_string_t *ret, const char*s);
void hello_cosmo_string_free(hello_cosmo_string_t *ret);

#ifdef __cplusplus
}
#endif
#endif
